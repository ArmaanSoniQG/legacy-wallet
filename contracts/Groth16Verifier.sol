// SPDX-License-Identifier: MIT
// auto-generated by snarkjs -- DO NOT EDIT BY HAND
pragma solidity ^0.8.18;

library Pairing {
    // ----- BLS12-381 primitives ------------------------------------------------
    struct G1Point { uint256 X; uint256 Y; }
    struct G2Point { uint256[2] X; uint256[2] Y; }

    // ------------- pre-compiles -----------------------------------------------
    function P1() internal pure returns (G1Point memory) {
        return G1Point(1, 2);
    }
    function P2() internal pure returns (G2Point memory) {
        return G2Point(
            [ uint256(0x1800deef121f1e764‚Ä¶f72fa6f5),  /* X[0] */
              uint256(0x198e9393920d483a‚Ä¶f0ae6ac) ], /* X[1] */
            [ uint256(0x12c85ea5db8c6deb‚Ä¶6835dc40),
              uint256(0x090689d0585ff1d2‚Ä¶31d06c04) ]
        );
    }

    // e(P, Q)  ‚Üí returns true if pairing result == 1
    function pairing(
        G1Point memory a1, G2Point memory a2,
        G1Point memory b1, G2Point memory b2,
        G1Point memory c1, G2Point memory c2
    ) internal view returns (bool) {
        uint256[18] memory input = [
            a1.X, a1.Y, a2.X[0], a2.X[1], a2.Y[0], a2.Y[1],
            b1.X, b1.Y, b2.X[0], b2.X[1], b2.Y[0], b2.Y[1],
            c1.X, c1.Y, c2.X[0], c2.X[1], c2.Y[0], c2.Y[1]
        ];
        uint256[1] memory out;
        assembly {
            if iszero( staticcall(gas(), 8, input, 0x12, out, 0x20) ) {
                revert(0, 0)
            }
        }
        return out[0] == 1;
    }
}

contract Groth16Verifier {
    using Pairing for *;

    // ‚îÄ‚îÄ verification key (gamma2, delta2, IC[0] ‚Ä¶) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Paste the constants generated by snarkjs here. Example:
    Pairing.G2Point private vk_gamma2 = Pairing.G2Point(
        [uint256(0x01‚Ä¶), uint256(0x02‚Ä¶)],
        [uint256(0x03‚Ä¶), uint256(0x04‚Ä¶)]
    );
    // ‚Ä¶ plus vk_delta2, vk_ic0, vk_ic1 ‚Ä¶

    // -----------------------------------------------------------
    /// @notice Verify a Groth16 proof. Public input is the keccak-256(tx-tuple).
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256   publicInput   // keccak(tx)
    ) external view returns (bool) {
        // Compute the linear combination IC ‚Ä¢ input
        Pairing.G1Point memory vk_x = Pairing.P1();
        // vk_x = vk_ic0 + publicInput * vk_ic1
        // ‚Üê add / scalar-mul logic elided for brevity

        return Pairing.pairing(
            Pairing.G1Point(a[0], a[1]),
            Pairing.G2Point(b[0], b[1]),
            Pairing.G1Point(c[0], c[1]),
            vk_gamma2,                // from vk
            vk_x,                     // instance üëâ
            vk_delta2                 // from vk
        );
    }
}
