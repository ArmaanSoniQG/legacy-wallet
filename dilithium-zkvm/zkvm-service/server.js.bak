const express = require('express');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const cors = require('cors');

const app = express();
app.use(cors());
app.use(express.json());

const HOST_BINARY_PATH = '../target/release/host';

/**
 * Run the host binary with given arguments
 */
async function runHostBinary(args) {
    return new Promise((resolve) => {
        const process = spawn(HOST_BINARY_PATH, args);
        let stdout = '';
        let stderr = '';
        
        process.stdout.on('data', (data) => {
            stdout += data.toString();
        });
        
        process.stderr.on('data', (data) => {
            stderr += data.toString();
        });
        
        process.on('close', (code) => {
            resolve({
                success: code === 0,
                stdout,
                stderr,
                exitCode: code
            });
        });
    });
}

/**
 * Generate Dilithium-5 key pair
 * POST /generate-key
 * Returns: { success: boolean, publicKey: string, privateKey: string, publicKeyHash: string }
 */
app.post('/generate-key', async (req, res) => {
    try {
        // Generate real Dilithium-5 key pair
        const result = await runHostBinary(['generate-keypair']);
        
        if (!result.success) {
            throw new Error(result.stderr || 'Key generation failed');
        }
        
        // Parse the output to extract keys
        const lines = result.stdout.split('\n');
        const hashLine = lines.find(line => line.includes('Public key hash:'));
        
        const publicKeyHash = hashLine ? hashLine.split('Public key hash: ')[1].trim() : '';
        
        // Read the generated key files
        const publicKey = fs.readFileSync('public_key.bin').toString('hex');
        const privateKey = fs.readFileSync('private_key.bin').toString('hex');
        
        res.json({
            success: true,
            publicKey,
            privateKey,
            publicKeyHash
        });
        
    } catch (error) {
        console.error('Key generation error:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

/**
 * Sign message and generate zkVM proof
 * POST /verify
 * Body: { message: string }
 * Returns: { success: boolean, proof: { journal: string, seal: string, isValid: boolean } }
 */
app.post('/verify', async (req, res) => {
    try {
        const { message } = req.body;
        
        if (!message) {
            throw new Error('Message is required');
        }
        
        // Step 1: Sign the message
        const signResult = await runHostBinary([
            'sign',
            '--private-key', 'private_key.bin',
            '--message', message,
            '--output', 'signature.bin'
        ]);
        
        if (!signResult.success) {
            throw new Error('Signing failed: ' + signResult.stderr);
        }
        
        // Step 2: Verify and generate zkVM proof
        const verifyResult = await runHostBinary([
            'verify',
            '--public-key', 'public_key.bin',
            '--signature', 'signature.bin',
            '--message', message,
            '--output', 'receipt.bin'
        ]);
        
        if (!verifyResult.success) {
            throw new Error('Verification failed: ' + verifyResult.stderr);
        }
        
        // Step 3: Extract proof data
        const extractResult = await runHostBinary([
            'extract',
            '--receipt', 'receipt.bin',
            '--format', 'hex'
        ]);
        
        if (!extractResult.success) {
            throw new Error('Proof extraction failed: ' + extractResult.stderr);
        }
        
        // Parse the extracted proof data
        const lines = extractResult.stdout.trim().split('\n');
        const journalLine = lines.find(l => l.startsWith('journal:'));
        const sealLine = lines.find(l => l.startsWith('seal:'));
        
        const journal = journalLine ? journalLine.split(': ')[1] : '';
        const seal = sealLine ? sealLine.split(': ')[1] : '';
        
        res.json({
            success: true,
            proof: {
                journal,
                seal,
                isValid: true
            }
        });
        
    } catch (error) {
        console.error('Verification error:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
    console.log(`zkVM service running on port ${PORT}`);
});